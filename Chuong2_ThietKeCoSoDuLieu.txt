================================================================================
CHƯƠNG 2: PHÂN TÍCH VÀ THIẾT KẾ HỆ THỐNG
Phần 2.3: THIẾT KẾ CƠ SỞ DỮ LIỆU
Phần thực hiện: Ngô Việt Anh (phối hợp với Phạm Ngọc Đăng)
================================================================================

2.3.1. TỔNG QUAN THIẾT KẾ CƠ SỞ DỮ LIỆU

Cơ sở dữ liệu của hệ thống EV-Swap được thiết kế theo mô hình quan hệ (Relational 
Database) nhằm đảm bảo tính toàn vẹn và nhất quán dữ liệu trong các giao dịch 
đổi pin. Hệ thống bao gồm 12 bảng chính với các mối quan hệ phức tạp.

Công nghệ sử dụng:
- Database: PostgreSQL 14
- ORM: Prisma 5.22.0
- Hosting: AWS RDS (thông qua Heroku Postgres)

2.3.2. BIỂU ĐỒ THỰC THỂ - LIÊN KẾT (ERD)

Sơ đồ PlantUML mô tả các entities và relationships:

```plantuml
@startuml EV-Swap ERD

entity "Customer" as customer {
  * id : INT <<PK>>
  --
  * fullName : VARCHAR(100)
  * username : VARCHAR(50) <<UNIQUE>>
  * passwordHash : VARCHAR(255)
  * phone : VARCHAR(20) <<UNIQUE>>
  * email : VARCHAR(100) <<UNIQUE>>
  currentBatteryUid : VARCHAR(50) <<FK>>
  totalSwaps : INT
  balance : DOUBLE
  avatarUrl : TEXT
  createdAt : TIMESTAMP
}

entity "Battery" as battery {
  * uid : VARCHAR(50) <<PK>>
  --
  * status : VARCHAR(50)
  chargeCycles : INT
  lastCharged : TIMESTAMP
  createdAt : TIMESTAMP
}

entity "Station" as station {
  * id : INT <<PK>>
  --
  * name : VARCHAR(100) <<UNIQUE>>
  location : VARCHAR(255)
  status : VARCHAR(50)
  totalSlots : INT
  availableSlots : INT
  lastMaintenance : TIMESTAMP
  createdAt : TIMESTAMP
}

entity "Slot" as slot {
  * id : INT <<PK>>
  --
  * stationId : INT <<FK>>
  * slotNumber : INT
  * status : VARCHAR(50)
  isBatteryPresent : BOOLEAN
  isLocked : BOOLEAN
  batteryUid : VARCHAR(50) <<FK>>
  lastUpdated : TIMESTAMP
}

entity "TransactionLog" as transaction {
  * id : INT <<PK>>
  --
  * customerId : INT <<FK>>
  * stationId : INT <<FK>>
  * requestType : VARCHAR(50)
  oldBatteryUid : VARCHAR(50) <<FK>>
  slotIn : INT
  newBatteryUid : VARCHAR(50) <<FK>>
  slotOut : INT
  cost : DOUBLE
  transactionTime : TIMESTAMP
  completedTime : TIMESTAMP
  status : VARCHAR(50)
}

entity "Payment" as payment {
  * id : INT <<PK>>
  --
  * customerId : INT <<FK>>
  * orderId : VARCHAR(50) <<UNIQUE>>
  requestId : VARCHAR(50)
  amount : DOUBLE
  status : VARCHAR(50)
  paymentMethod : VARCHAR(50)
  transactionId : VARCHAR(100)
  momoData : JSONB
  createdAt : TIMESTAMP
  completedAt : TIMESTAMP
}

entity "Reservation" as reservation {
  * id : INT <<PK>>
  --
  * customerId : INT <<FK>>
  * stationId : INT <<FK>>
  reservedTime : TIMESTAMP
  status : VARCHAR(50)
  batteryUid : VARCHAR(50)
  createdAt : TIMESTAMP
  updatedAt : TIMESTAMP
}

entity "Feedback" as feedback {
  * feedbackId : INT <<PK>>
  --
  * customerId : INT <<FK>>
  content : TEXT
  rating : INT
  feedbackDate : TIMESTAMP
}

entity "Admin" as admin {
  * id : INT <<PK>>
  --
  * username : VARCHAR(50) <<UNIQUE>>
  * passwordHash : VARCHAR(255)
  fullName : VARCHAR(100)
  role : VARCHAR(50)
  email : VARCHAR(100)
  createdAt : TIMESTAMP
  updatedAt : TIMESTAMP
}

entity "MaintenanceLog" as maintenance {
  * id : INT <<PK>>
  --
  * stationId : INT <<FK>>
  * adminId : INT <<FK>>
  * maintenanceType : VARCHAR(50)
  description : TEXT
  startTime : TIMESTAMP
  endTime : TIMESTAMP
  status : VARCHAR(50)
}

entity "Warehouse" as warehouse {
  * id : INT <<PK>>
  --
  * slotId : INT <<FK>>
  * totalCapacity : INT
}

entity "WarehouseBattery" as warehouse_battery {
  * id : INT <<PK>>
  --
  * warehouseId : INT <<FK>>
  * batteryUid : VARCHAR(50) <<FK>>
  insertedAt : TIMESTAMP
}

' Relationships
customer ||--o{ transaction : "makes"
customer ||--o| battery : "currently_using"
customer ||--o{ payment : "pays"
customer ||--o{ reservation : "books"
customer ||--o{ feedback : "gives"

station ||--|{ slot : "contains"
station ||--o{ transaction : "handles"
station ||--o{ reservation : "has"
station ||--o{ maintenance : "requires"

battery ||--o{ slot : "placed_in"
battery ||--o{ transaction : "old_battery"
battery ||--o{ transaction : "new_battery"

slot }o--|| station : "belongs_to"
slot }o--o| battery : "contains"

transaction }o--|| customer : "belongs_to"
transaction }o--|| station : "occurs_at"
transaction }o--o| battery : "uses_old"
transaction }o--o| battery : "uses_new"

admin ||--o{ maintenance : "performs"
maintenance }o--|| station : "on_station"
maintenance }o--o| admin : "performed_by"

slot ||--o| warehouse : "has_warehouse"
warehouse }o--|| slot : "belongs_to"
warehouse ||--o{ warehouse_battery : "contains"
warehouse_battery }o--|| warehouse : "stored_in"
battery ||--o{ warehouse_battery : "stored_as"
warehouse_battery }o--|| battery : "is_battery"

@enduml
```

2.3.3. MÔ TẢ CHI TIẾT CÁC BẢNG (ENTITIES)

2.3.3.1. Bảng CUSTOMERS - Quản lý người dùng

Bảng này lưu trữ thông tin đầy đủ về khách hàng sử dụng dịch vụ đổi pin.

Schema trong Prisma:
```prisma
model Customer {
  id                Int      @id @default(autoincrement())
  fullName          String   @map("full_name") @db.VarChar(100)
  username          String   @unique @db.VarChar(50)
  passwordHash      String   @map("password_hash") @db.VarChar(255)
  phone             String?  @unique @db.VarChar(20)
  email             String?  @unique @db.VarChar(100)
  currentBatteryUid String?  @map("current_battery_uid") @db.VarChar(50)
  totalSwaps        Int      @default(0) @map("total_swaps")
  balance           Float    @default(0) @db.DoublePrecision
  avatarUrl         String?  @map("avatar_url") @db.Text
  createdAt         DateTime @default(now()) @map("created_at")

  currentBattery   Battery? @relation(fields: [currentBatteryUid], references: [uid])
  transactionLogs  TransactionLog[]
  feedbacks        Feedback[]
  reservations     Reservation[]
  payments         Payment[]

  @@map("customers")
}
```

Các trường quan trọng:
- id: Primary key tự tăng
- username: Duy nhất, dùng để đăng nhập
- passwordHash: Mật khẩu được hash bằng bcrypt (salt rounds = 10)
- phone: Duy nhất, dùng cho chức năng reset password
- email: Duy nhất, dùng cho notification
- currentBatteryUid: Foreign key đến Battery, lưu pin đang sử dụng (có thể NULL)
- totalSwaps: Đếm số lần đổi pin, tăng sau mỗi giao dịch thành công
- balance: Số dư ví điện tử (đơn vị: VNĐ)

Constraints:
- UNIQUE(username): Đảm bảo không trùng tên đăng nhập
- UNIQUE(phone): Mỗi số điện thoại chỉ đăng ký một tài khoản
- UNIQUE(email): Mỗi email chỉ đăng ký một tài khoản
- Foreign Key(currentBatteryUid) ON DELETE SET NULL: Nếu pin bị xóa, set NULL

2.3.3.2. Bảng BATTERIES - Quản lý pin

Mỗi viên pin có một UID duy nhất (dạng RFID tag) được theo dõi trong hệ thống.

Schema:
```prisma
model Battery {
  uid              String   @id @db.VarChar(50)
  status           String   @default("in_stock") @db.VarChar(50)
  chargeCycles     Int      @default(0) @map("charge_cycles")
  lastCharged      DateTime? @map("last_charged")
  createdAt        DateTime @default(now()) @map("created_at")

  customers        Customer[]
  slots            Slot[]
  transactionLogsOld TransactionLog[] @relation("OldBattery")
  transactionLogsNew TransactionLog[] @relation("NewBattery")

  @@map("batteries")
}
```

Các trường:
- uid: Primary key (STRING), format "UID-001", "UID-002"...
- status: Trạng thái pin
  + "in_stock": Pin đầy điện, sẵn sàng để đổi
  + "charging": Đang sạc
  + "in_use": Đang được khách hàng sử dụng
  + "maintenance": Đang bảo trì
- chargeCycles: Số chu kỳ sạc, dùng để đánh giá sức khỏe pin
- lastCharged: Timestamp lần sạc gần nhất

Lý do không có trường chargeLevel (mức pin):
- Mức pin thay đổi liên tục trong quá trình sử dụng
- Dữ liệu realtime được lấy từ IoT device, không lưu trong DB
- DB chỉ lưu status để phân loại pin (đầy, đang sạc, đang dùng)

2.3.3.3. Bảng STATIONS - Quản lý trạm đổi pin

Schema:
```prisma
model Station {
  id               Int      @id @default(autoincrement())
  name             String   @unique @db.VarChar(100)
  location         String?  @db.VarChar(255)
  status           String   @default("inactive") @db.VarChar(50)
  totalSlots       Int      @default(6) @map("total_slots")
  availableSlots   Int      @default(6) @map("available_slots")
  lastMaintenance  DateTime? @map("last_maintenance")
  createdAt        DateTime @default(now()) @map("created_at")

  slots            Slot[]
  transactionLogs  TransactionLog[]
  reservations     Reservation[]

  @@map("stations")
}
```

Trường đặc biệt - location:
Format: "Address;latitude;longitude"
Ví dụ: "Học viện Công nghệ Bưu chính Viễn thông Hà Nội;21.0063;105.8433"

Frontend parse bằng cách:
```javascript
const [address, lat, lng] = station.location.split(';');
const latitude = parseFloat(lat);
const longitude = parseFloat(lng);
```

Lý do thiết kế:
- Tiết kiệm columns trong database
- Dễ dàng migrate từ hardcoded coordinates sang DB-driven
- Frontend linh hoạt extract từng phần khi cần

Trường status:
- "active": Hoạt động bình thường
- "inactive": Tạm ngưng
- "maintenance": Đang bảo trì
- "out_of_battery": Hết pin khả dụng

Logic auto-update status:
```javascript
if (availableSlots === 0) {
  status = "out_of_battery";
} else if (availableSlots >= 2) {
  status = "active";
}
```

2.3.3.4. Bảng SLOTS - Quản lý khay chứa pin trong trạm

Mỗi trạm có nhiều slots (mặc định 6 slots), mỗi slot có thể chứa một viên pin.

Schema:
```prisma
model Slot {
  id                 Int      @id @default(autoincrement())
  stationId          Int      @map("station_id")
  slotNumber         Int      @map("slot_number")
  status             String   @default("empty") @db.VarChar(50)
  isBatteryPresent   Boolean  @default(false) @map("is_battery_present")
  isLocked           Boolean  @default(false) @map("is_locked")
  batteryUid         String?  @map("battery_uid") @db.VarChar(50)
  lastUpdated        DateTime @default(now()) @map("last_updated")

  station            Station  @relation(fields: [stationId], references: [id], onDelete: Cascade)
  battery            Battery? @relation(fields: [batteryUid], references: [uid], onDelete: SetNull)

  @@unique([stationId, slotNumber])
  @@map("slots")
}
```

Các trường:
- slotNumber: Số thứ tự slot trong trạm (1, 2, 3, 4, 5, 6)
- status:
  + "empty": Trống, không có pin
  + "occupied": Có pin sẵn sàng
  + "charging": Đang sạc pin
  + "error": Lỗi phần cứng
- isBatteryPresent: Sensor phát hiện có pin hay không
- isLocked: Trạng thái khóa cơ (mở/khóa)
- batteryUid: Foreign key đến Battery (NULL nếu slot trống)

Unique Constraint:
- (stationId, slotNumber): Đảm bảo không trùng số slot trong cùng trạm

Cascade Rules:
- ON DELETE CASCADE: Nếu trạm bị xóa, tất cả slots cũng bị xóa
- ON DELETE SET NULL: Nếu pin bị xóa, batteryUid = NULL nhưng slot vẫn tồn tại

2.3.3.5. Bảng TRANSACTION_LOGS - Lịch sử giao dịch đổi pin

Bảng này ghi nhận toàn bộ quá trình đổi pin từ lúc bắt đầu đến hoàn tất.

Schema:
```prisma
model TransactionLog {
  id              Int      @id @default(autoincrement())
  customerId      Int      @map("customer_id")
  stationId       Int      @map("station_id")
  requestType     String   @default("swap") @map("request_type")
  oldBatteryUid   String?  @map("old_battery_uid")
  slotIn          Int?     @map("slot_in")
  newBatteryUid   String?  @map("new_battery_uid")
  slotOut         Int?     @map("slot_out")
  cost            Float    @default(7000)
  transactionTime DateTime @default(now()) @map("transaction_time")
  completedTime   DateTime? @map("completed_time")
  status          String   @default("pending")

  customer        Customer @relation(fields: [customerId], references: [id])
  station         Station  @relation(fields: [stationId], references: [id])
  oldBattery      Battery? @relation("OldBattery", fields: [oldBatteryUid], references: [uid])
  newBattery      Battery? @relation("NewBattery", fields: [newBatteryUid], references: [uid])

  @@map("transaction_logs")
}
```

Luồng giao dịch:
1. Customer quét QR tại trạm
2. POST /api/transactions/start-swap
   - status = "pending"
   - transactionTime = NOW()
   - Chọn pin mới từ slots có status="in_stock"
   - Gán slotOut (slot lấy pin mới)
3. Hardware mở khóa slotOut
4. Customer lấy pin mới
5. Hardware sensor phát hiện pin mới được lấy đi
6. POST /api/transactions/:id/complete-swap
   - status = "completed"
   - completedTime = NOW()
   - Trừ balance của customer (7000đ)
   - Cập nhật currentBatteryUid của customer

Trường requestType:
- "swap": Đổi pin (phổ biến nhất)
- "return": Trả pin (hiếm, khi khách không còn dùng xe nữa)

2.3.3.6. Bảng PAYMENTS - Quản lý thanh toán

Schema:
```prisma
model Payment {
  id            Int      @id @default(autoincrement())
  customerId    Int      @map("customer_id")
  orderId       String   @unique @map("order_id") @db.VarChar(50)
  requestId     String   @map("request_id") @db.VarChar(50)
  amount        Float
  status        String   @default("pending")
  paymentMethod String   @map("payment_method")
  transactionId String?  @map("transaction_id") @db.VarChar(100)
  momoData      Json?    @map("momo_data")
  errorMessage  String?  @map("error_message")
  createdAt     DateTime @default(now()) @map("created_at")
  completedAt   DateTime? @map("completed_at")

  customer      Customer @relation(fields: [customerId], references: [id])

  @@map("payments")
}
```

Luồng thanh toán MoMo:
1. Customer nhấn "Nạp tiền" trong ứng dụng
2. POST /api/payment/momo/create
   - Tạo orderId unique (format: MOMO_{timestamp}_{userId})
   - Tạo requestId unique
   - Tính signature HMAC SHA256
   - Gọi MoMo API để tạo payment request
3. Redirect customer đến MoMo app
4. Customer xác nhận thanh toán trên MoMo
5. MoMo gọi callback: POST /api/payment/momo/callback
   - Verify signature từ MoMo
   - Update status = "completed"
   - Cộng amount vào customer.balance
   - Ghi momoData (JSON) từ MoMo response

Trường momoData (JSONB):
Lưu toàn bộ response từ MoMo để audit/debug:
```json
{
  "partnerCode": "MOMO",
  "orderId": "MOMO_1702468800_123",
  "requestId": "REQ_1702468800_123",
  "amount": 50000,
  "orderInfo": "Nạp tiền vào ví",
  "transId": "2891234567",
  "resultCode": 0,
  "message": "Successful",
  "payType": "qr",
  "responseTime": 1702468900000
}
```

2.3.3.7. Bảng RESERVATIONS - Đặt chỗ trước

Cho phép khách hàng đặt trước pin tại một trạm cụ thể.

Schema:
```prisma
model Reservation {
  id            Int      @id @default(autoincrement())
  customerId    Int      @map("customer_id")
  stationId     Int      @map("station_id")
  reservedTime  DateTime @map("reserved_time")
  status        String   @default("pending")
  batteryUid    String?  @map("battery_uid")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  customer      Customer @relation(fields: [customerId], references: [id])
  station       Station  @relation(fields: [stationId], references: [id])

  @@map("reservations")
}
```

Status lifecycle:
- "pending": Mới tạo, chưa xử lý
- "confirmed": Hệ thống đã chọn pin và slot cho customer
- "completed": Customer đã đến và hoàn tất đổi pin
- "cancelled": Customer hủy reservation
- "expired": Quá thời gian (30 phút) chưa đến

Quy trình:
1. Customer chọn trạm và thời gian dự kiến
2. POST /api/reservations/create
   - Kiểm tra trạm có pin khả dụng không
   - Tạo reservation với status="pending"
3. Background job chạy định kỳ:
   - Check reservations sắp đến (trong 10 phút tới)
   - Assign một pin cụ thể: batteryUid
   - Update status="confirmed"
4. Customer đến trạm trong 30 phút
5. Quét QR và start transaction
   - Ưu tiên dùng pin đã reserve (batteryUid)
   - Update reservation status="completed"

2.3.3.8. Bảng FEEDBACKS - Đánh giá dịch vụ

Schema:
```prisma
model Feedback {
  feedbackId   Int      @id @default(autoincrement()) @map("feedback_id")
  customerId   Int      @map("customer_id")
  content      String   @db.Text
  rating       Int?
  feedbackDate DateTime @default(now()) @map("feedback_date")

  customer     Customer @relation(fields: [customerId], references: [id])

  @@map("feedbacks")
}
```

Đơn giản, chỉ lưu:
- content: Nội dung phản hồi
- rating: Đánh giá từ 1-5 sao (optional)
- feedbackDate: Thời gian gửi

2.3.3.9. Bảng ADMINS - Quản trị viên

Bảng này lưu trữ thông tin tài khoản quản trị viên, tách biệt hoàn toàn với 
bảng customers.

Schema trong Prisma:
```prisma
model Admin {
  id           Int      @id @default(autoincrement())
  username     String   @unique @db.VarChar(50)
  passwordHash String   @map("password_hash") @db.VarChar(255)
  fullName     String?  @map("full_name") @db.VarChar(100)
  role         String   @default("user") @db.VarChar(50)
  email        String?  @unique @db.VarChar(100)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  maintenanceLogs MaintenanceLog[]

  @@map("admins")
}
```

SQL Schema (từ Database.sql):
```sql
CREATE TABLE admins (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100),
    role VARCHAR(50) NOT NULL DEFAULT 'user',
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ
);
```

Các trường quan trọng:
- id: Primary key tự tăng
- username: Duy nhất, dùng để đăng nhập vào admin web
- passwordHash: Mật khẩu được hash bằng bcrypt (salt rounds = 10)
- fullName: Tên đầy đủ của admin (optional)
- role: Vai trò quản trị
  + "user": Admin thông thường, quyền hạn giới hạn
  + "superadmin": Admin cấp cao, full quyền
  + "viewer": Chỉ xem, không chỉnh sửa
- email: Email liên hệ, dùng cho forgot password
- updatedAt: Tự động cập nhật khi thay đổi thông tin

Constraints:
- UNIQUE(username): Đảm bảo không trùng tên đăng nhập
- UNIQUE(email): Mỗi email chỉ dùng cho 1 tài khoản admin
- NOT NULL(username, password_hash): Bắt buộc khi tạo admin

**Khác biệt giữa Admin và Customer:**

| Tiêu chí | Admin | Customer |
|-----------|-------|----------|
| Bảng | admins | customers |
| Ứng dụng | Admin Web (ev-swap-admin) | Mobile App (ev-swap) |
| Authentication | Session-based | JWT Token |
| Quyền hạn | Quản trị hệ thống | Sử dụng dịch vụ |
| Fields đặc biệt | role (user/superadmin) | balance, currentBatteryUid |
| Foreign Keys | MaintenanceLog | TransactionLog, Payment, Reservation |

**Sample data:**
```sql
INSERT INTO admins (username, password_hash, full_name, role, email)
VALUES 
  ('admin', '$2b$10$abcdefghijklmnop...', 'Nguyễn Văn Admin', 'superadmin', 'admin@evswap.com'),
  ('staff1', '$2b$10$qrstuvwxyz12345...', 'Trần Thị B', 'user', 'staff1@evswap.com'),
  ('viewer', '$2b$10$67890abcdef...', 'Phạm Văn C', 'viewer', 'viewer@evswap.com');
```

**Use cases:**
1. **Login Admin Web:**
```sql
SELECT * FROM admins WHERE username = 'admin';
-- Verify password với bcrypt.compare()
```

2. **Forgot Password:**
```sql
SELECT username, full_name, role 
FROM admins 
WHERE username = 'admin' OR email = 'admin@evswap.com';
```

3. **Reset Password:**
```sql
UPDATE admins 
SET password_hash = '$2b$10$new_hash...', 
    updated_at = CURRENT_TIMESTAMP 
WHERE username = 'admin';
```

2.3.3.10. Bảng MAINTENANCE_LOGS - Lịch sử bảo trì

Bảng này ghi lại các lần bảo trì trạm do admin thực hiện.

Schema:
```prisma
model MaintenanceLog {
  id              Int      @id @default(autoincrement())
  stationId       Int      @map("station_id")
  adminId         Int?     @map("admin_id")
  maintenanceType String   @map("maintenance_type") @db.VarChar(50)
  description     String?  @db.Text
  startTime       DateTime @default(now()) @map("start_time")
  endTime         DateTime? @map("end_time")
  status          String   @default("in_progress") @db.VarChar(50)

    station         Station  @relation(fields: [stationId], references: [id], onDelete: Cascade)
    admin           Admin?   @relation(fields: [adminId], references: [id], onDelete: SetNull)

    @@map("maintenance_logs")
}
```

SQL Schema:
```sql
CREATE TABLE maintenance_logs (
    id SERIAL PRIMARY KEY,
    station_id INT NOT NULL REFERENCES stations(id) ON DELETE CASCADE,
    admin_id INT REFERENCES admins(id) ON DELETE SET NULL,
    maintenance_type VARCHAR(50) NOT NULL,
    description TEXT,
    start_time TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    end_time TIMESTAMPTZ,
    status VARCHAR(50) NOT NULL DEFAULT 'in_progress'
);
```

Các trường:
- stationId: Trạm đang bảo trì
- adminId: Admin thực hiện (có thể NULL nếu admin bị xóa)
- maintenanceType: Loại bảo trì
  + "routine": Bảo trì định kỳ
  + "repair": Sửa chữa
  + "upgrade": Nâng cấp
  + "inspection": Kiểm tra
- description: Mô tả chi tiết công việc
- startTime: Thời gian bắt đầu
- endTime: Thời gian kết thúc (NULL nếu chưa xong)
- status:
  + "in_progress": Đang tiến hành
  + "completed": Hoàn thành
  + "cancelled": Hủy bỏ

Cascade Rules:
- ON DELETE CASCADE (station): Nếu trạm bị xóa, xóa luôn lịch sử bảo trì
- ON DELETE SET NULL (admin): Nếu admin bị xóa, giữ log nhưng adminId = NULL

**Workflow bảo trì:**

1. **Bắt đầu bảo trì:**
```sql
-- Tạo maintenance log
INSERT INTO maintenance_logs (station_id, admin_id, maintenance_type, description)
VALUES (1, 1, 'repair', 'Thay thế cảm biến slot 3');

-- Cập nhật trạng thái trạm
UPDATE stations 
SET status = 'maintenance', 
    last_maintenance = CURRENT_TIMESTAMP 
WHERE id = 1;
```

2. **Hoàn thành bảo trì:**
```sql
-- Cập nhật maintenance log
UPDATE maintenance_logs 
SET status = 'completed', 
    end_time = CURRENT_TIMESTAMP 
WHERE id = 45;

-- Cập nhật trạng thái trạm về active
UPDATE stations 
SET status = 'active' 
WHERE id = 1;
```

3. **Thống kê bảo trì:**
```sql
-- Số lần bảo trì theo trạm
SELECT 
  s.name AS station_name,
  COUNT(ml.id) AS maintenance_count,
  MAX(ml.end_time) AS last_maintenance
FROM stations s
LEFT JOIN maintenance_logs ml ON s.id = ml.station_id
WHERE ml.status = 'completed'
GROUP BY s.id, s.name
ORDER BY maintenance_count DESC;
```

2.3.3.11. Bảng WAREHOUSE - Kho chứa pin dự phòng

Bảng này quản lý kho chứa pin dự phòng tại mỗi slot. Mỗi slot có thể có một 
warehouse để chứa pin backup.

Schema trong Prisma:
```prisma
model Warehouse {
  id            Int                @id @default(autoincrement())
  slotId        Int                @map("slot_id")
  totalCapacity Int                @default(4) @map("total_capacity")
  
  slot          Slot               @relation(fields: [slotId], references: [id], onDelete: Cascade)
  batteries     WarehouseBattery[]

  @@map("warehouse")
}
```

SQL Schema:
```sql
CREATE TABLE warehouse (
    id SERIAL PRIMARY KEY,
    slot_id INT NOT NULL REFERENCES slots(id) ON DELETE CASCADE,
    total_capacity INT NOT NULL DEFAULT 4
);
```

Các trường:
- id: Primary key tự tăng
- slotId: Foreign key đến Slot (1 slot có 1 warehouse)
- totalCapacity: Số lượng pin tối đa có thể chứa (mặc định: 4 pin)

Cascade Rule:
- ON DELETE CASCADE: Nếu slot bị xóa, warehouse cũng bị xóa

**Mục đích:**
- Lưu trữ pin dự phòng tại mỗi vị trí slot
- Đảm bảo luôn có pin sẵn sàng khi khách hàng đến đổi
- Tối ưu hóa việc quản lý inventory

2.3.3.12. Bảng WAREHOUSE_BATTERIES - Pin trong kho

Bảng này liên kết giữa warehouse và batteries, cho phép tracking từng viên pin 
trong kho.

Schema trong Prisma:
```prisma
model WarehouseBattery {
  id          Int       @id @default(autoincrement())
  warehouseId Int       @map("warehouse_id")
  batteryUid  String    @map("battery_uid") @db.VarChar(50)
  insertedAt  DateTime  @default(now()) @map("inserted_at") @db.Timestamp(6)
  
  battery     Battery   @relation(fields: [batteryUid], references: [uid])
  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)

  @@map("warehouse_batteries")
}
```

SQL Schema:
```sql
CREATE TABLE warehouse_batteries (
    id SERIAL PRIMARY KEY,
    warehouse_id INT NOT NULL REFERENCES warehouse(id) ON DELETE CASCADE,
    battery_uid VARCHAR(50) NOT NULL REFERENCES batteries(uid),
    inserted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

Các trường:
- id: Primary key tự tăng
- warehouseId: Foreign key đến Warehouse
- batteryUid: Foreign key đến Battery
- insertedAt: Thời điểm đưa pin vào kho

Cascade Rule:
- ON DELETE CASCADE: Nếu warehouse bị xóa, xóa luôn records trong warehouse_batteries

**Use cases:**

1. **Thêm pin vào warehouse:**
```sql
INSERT INTO warehouse_batteries (warehouse_id, battery_uid)
VALUES (1, 'BAT025');

-- Cập nhật status pin
UPDATE batteries 
SET status = 'in_stock' 
WHERE uid = 'BAT025';
```

2. **Lấy pin từ warehouse:**
```sql
-- Tìm pin sẵn sàng trong warehouse
SELECT wb.battery_uid, b.charge_cycles
FROM warehouse_batteries wb
JOIN batteries b ON wb.battery_uid = b.uid
WHERE wb.warehouse_id = 1 
  AND b.status = 'in_stock'
ORDER BY b.charge_cycles ASC  -- Ưu tiên pin mới
LIMIT 1;

-- Xóa khỏi warehouse sau khi lấy
DELETE FROM warehouse_batteries 
WHERE warehouse_id = 1 AND battery_uid = 'BAT025';
```

3. **Kiểm tra dung lượng warehouse:**
```sql
SELECT 
  w.id,
  w.total_capacity,
  COUNT(wb.id) AS current_count,
  (w.total_capacity - COUNT(wb.id)) AS available_space
FROM warehouse w
LEFT JOIN warehouse_batteries wb ON w.id = wb.warehouse_id
GROUP BY w.id, w.total_capacity;
```

**Lợi ích:**
- Theo dõi chính xác số lượng pin dự trữ tại mỗi slot
- Biết được thời gian pin nằm trong kho (insertedAt)
- Dễ dàng restock khi warehouse gần hết

2.3.4. CÁC QUAN HỆ GIỮA CÁC BẢNG (RELATIONSHIPS)2.3.4.1. One-to-Many (1-N)

a) Customer - TransactionLog (1-N):
Một khách hàng có thể có nhiều giao dịch đổi pin.
```prisma
Customer {
  transactionLogs TransactionLog[]  // Array of transactions
}
TransactionLog {
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id])
}
```

b) Station - Slot (1-N):
Một trạm có nhiều slots (cascade delete).
```prisma
Station {
  slots Slot[]
}
Slot {
  stationId Int
  station   Station @relation(..., onDelete: Cascade)
}
```
→ Khi xóa Station, tất cả Slots thuộc trạm đó cũng bị xóa.

c) Customer - Payment (1-N):
Một khách hàng có nhiều lịch sử nạp tiền.

d) Customer - Reservation (1-N):
Một khách hàng có thể đặt nhiều lần tại các trạm khác nhau.

e) Station - MaintenanceLog (1-N):
Một trạm có nhiều lần bảo trì.
```prisma
Station {
  maintenanceLogs MaintenanceLog[]
}
MaintenanceLog {
  stationId Int
  station   Station @relation(fields: [stationId], references: [id], onDelete: Cascade)
}
```

f) Admin - MaintenanceLog (1-N):
Một admin có thể thực hiện nhiều lần bảo trì.
```prisma
Admin {
  maintenanceLogs MaintenanceLog[]
}
MaintenanceLog {
  adminId Int?
  admin   Admin? @relation(fields: [adminId], references: [id], onDelete: SetNull)
}
```
→ Nếu admin bị xóa, giữ lại maintenance logs nhưng adminId = NULL.

g) Slot - Warehouse (1-1):
Mỗi slot có thể có một warehouse để chứa pin dự phòng.
```prisma
Slot {
  warehouses Warehouse[]
}
Warehouse {
  slotId Int
  slot   Slot @relation(fields: [slotId], references: [id], onDelete: Cascade)
}
```

h) Warehouse - WarehouseBattery (1-N):
Một warehouse có thể chứa nhiều pin.
```prisma
Warehouse {
  batteries WarehouseBattery[]
}
WarehouseBattery {
  warehouseId Int
  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
}
```

i) Battery - WarehouseBattery (1-N):
Một pin có thể được lưu trong nhiều warehouse records (lịch sử).
```prisma
Battery {
  warehouseBatteries WarehouseBattery[]
}
WarehouseBattery {
  batteryUid String
  battery    Battery @relation(fields: [batteryUid], references: [uid])
}
```

2.3.4.2. Many-to-One (N-1) với SetNull

a) Customer - Battery (N-1, optional):
Nhiều khách hàng có thể dùng cùng một loại pin (nhưng tại một thời điểm, 
mỗi customer chỉ có một pin).

```prisma
Customer {
  currentBatteryUid String?
  currentBattery    Battery? @relation(fields: [currentBatteryUid], ...)
}
```

Nếu pin bị xóa khỏi hệ thống:
```sql
ON DELETE SET NULL
```
→ currentBatteryUid của customer = NULL, không cascade delete customer.

b) Slot - Battery (N-1, optional):
Nhiều slots có thể chứa các pin khác nhau, hoặc không chứa pin (NULL).

2.3.4.3. Self-referencing với Named Relations

TransactionLog có 2 foreign keys đến Battery:
- oldBatteryUid: Pin khách hàng trả lại
- newBatteryUid: Pin mới khách hàng nhận

Prisma yêu cầu đặt tên relations:
```prisma
Battery {
  transactionLogsOld TransactionLog[] @relation("OldBattery")
  transactionLogsNew TransactionLog[] @relation("NewBattery")
}
TransactionLog {
  oldBattery Battery? @relation("OldBattery", fields: [oldBatteryUid], ...)
  newBattery Battery? @relation("NewBattery", fields: [newBatteryUid], ...)
}
```

2.3.5. INDEXES VÀ CONSTRAINTS

2.3.5.1. Primary Keys

Tất cả bảng có PK auto-increment (trừ Battery dùng UID string).

2.3.5.2. Unique Constraints

- customers.username
- customers.phone
- customers.email
- stations.name
- payments.orderId
- (slots.stationId, slots.slotNumber) - Composite unique

2.3.5.3. Indexes (Implicit)

Prisma tự động tạo index cho:
- Primary keys
- Foreign keys
- Unique constraints

Có thể thêm custom index:
```prisma
@@index([customerId, transactionTime])  // Optimize query lịch sử theo customer
```

2.3.6. PHÂN TÍCH CHUẨN HÓA (NORMALIZATION ANALYSIS)

Cơ sở dữ liệu EV-Swap được thiết kế tuân thủ các dạng chuẩn (Normal Forms) để 
đảm bảo tính nhất quán, tránh dư thừa dữ liệu và anomalies khi thao tác dữ liệu.

2.3.6.1. Dạng Chuẩn 1 (First Normal Form - 1NF)

**Định nghĩa 1NF:**
- Mỗi cột chỉ chứa giá trị nguyên tử (atomic value), không chứa tập hợp
- Không có nhóm lặp lại (repeating groups)
- Mỗi bản ghi có primary key duy nhất

**Phân tích các bảng:**

**✅ Bảng CUSTOMERS thỏa mãn 1NF:**
```
customers(id, fullName, username, passwordHash, phone, email, 
          currentBatteryUid, totalSwaps, balance, avatarUrl, createdAt)
```

- ✓ Mỗi trường chứa giá trị đơn (không có array)
- ✓ Có primary key: `id`
- ✓ Không có nhóm lặp: Nếu customer có nhiều giao dịch, được lưu ở bảng 
  `transaction_logs` riêng, không lưu trong customers

**✅ Bảng STATIONS thỏa mãn 1NF:**
```
stations(id, name, location, status, totalSlots, availableSlots, 
         lastMaintenance, createdAt)
```

**Lưu ý về trường `location`:**
Format: "Address;latitude;longitude"
Ví dụ: "Học viện PTIT;21.0063;105.8433"

**Có vi phạm 1NF không?**
- Về mặt kỹ thuật: KHÔNG vi phạm vì đây vẫn là một giá trị chuỗi nguyên tử
- Lý do chấp nhận: Trade-off giữa normalization và performance
  + Ưu điểm: Giảm số columns, dễ migrate từ hardcoded
  + Nhược điểm: Phải parse khi query (nhưng parsing rất nhanh)
  + Frontend parse: `const [addr, lat, lng] = location.split(';')`

**Nếu muốn chuẩn hóa hoàn toàn:**
```sql
-- Tách thành 3 columns riêng
stations(id, name, address, latitude, longitude, status, ...)
```
Nhưng trong dự án này, format "address;lat;lng" được chấp nhận vì:
- Luôn được sử dụng cùng nhau (không query riêng address hay lat/lng)
- Performance tốt hơn (ít columns hơn)
- Dễ validation (regex pattern)

**✅ Bảng TRANSACTION_LOGS thỏa mãn 1NF:**
```
transaction_logs(id, customerId, stationId, requestType, oldBatteryUid, 
                 slotIn, newBatteryUid, slotOut, cost, transactionTime, 
                 completedTime, status)
```

- ✓ Không lưu danh sách batteries trong một trường
- ✓ oldBatteryUid và newBatteryUid là 2 trường riêng (atomic)

**✅ Bảng PAYMENTS thỏa mãn 1NF:**
```
payments(id, customerId, orderId, requestId, amount, status, paymentMethod,
         transactionId, momoData, errorMessage, createdAt, completedAt)
```

**Lưu ý về trường `momoData` (JSONB):**
- Lưu JSON object từ MoMo response
- Có vi phạm 1NF không? **KHÔNG**
  + JSONB là kiểu dữ liệu atomic của PostgreSQL
  + Dùng cho semi-structured data không cần query thường xuyên
  + Use case: Audit log, debugging, không phải business logic

**Kết luận 1NF:**
✅ Tất cả 12 bảng trong hệ thống đều thỏa mãn 1NF.

2.3.6.2. Dạng Chuẩn 2 (Second Normal Form - 2NF)

**Định nghĩa 2NF:**
- Đã thỏa mãn 1NF
- Mọi thuộc tính không khóa phụ thuộc đầy đủ vào khóa chính (không có partial 
  dependency)

**Phân tích:**

**✅ Bảng CUSTOMERS (PK = id):**
```
customers(id, fullName, username, passwordHash, phone, email, 
          currentBatteryUid, totalSwaps, balance, avatarUrl, createdAt)
```

Primary key: `id` (single column)
- Không có composite key → Không thể có partial dependency
- ✓ Thỏa mãn 2NF

**✅ Bảng SLOTS (PK = id, Unique = stationId + slotNumber):**
```
slots(id, stationId, slotNumber, status, isBatteryPresent, isLocked, 
      batteryUid, lastUpdated)
```

Primary key: `id` (single column)
Unique constraint: `(stationId, slotNumber)`

**Kiểm tra partial dependency:**
- `status` phụ thuộc vào `id` (slot cụ thể) ✓
- `batteryUid` phụ thuộc vào `id` ✓
- `isBatteryPresent` phụ thuộc vào `id` ✓
- Không có trường nào chỉ phụ thuộc vào `stationId` hoặc chỉ `slotNumber`

**Ví dụ vi phạm 2NF (không có trong hệ thống):**
```sql
-- Nếu lưu thông tin trạm trong slots:
slots(id, stationId, slotNumber, stationName, stationLocation, ...)
```
→ `stationName`, `stationLocation` chỉ phụ thuộc `stationId`, không phụ thuộc `id`
→ Vi phạm 2NF → Tách ra bảng `stations` riêng ✓ (đã làm đúng)

**✅ Bảng TRANSACTION_LOGS (PK = id):**
```
transaction_logs(id, customerId, stationId, oldBatteryUid, newBatteryUid, ...)
```

**Kiểm tra:**
- `customerId` không lưu `customerName` trong transaction ✓
- `stationId` không lưu `stationName` trong transaction ✓
- Thông tin chi tiết lấy qua JOIN với bảng liên quan

**✅ Bảng WAREHOUSE_BATTERIES (PK = id):**
```
warehouse_batteries(id, warehouseId, batteryUid, insertedAt)
```

**Kiểm tra:**
- `insertedAt` phụ thuộc `id` (thời điểm pin cụ thể được thêm vào) ✓
- Không lưu thông tin pin (status, chargeCycles) trong warehouse_batteries ✓
- Join với bảng `batteries` để lấy thông tin chi tiết

**Kết luận 2NF:**
✅ Tất cả 12 bảng thỏa mãn 2NF vì:
- Đều dùng single-column primary key (`id` hoặc `uid`)
- Không có partial dependency
- Thông tin liên quan được tách thành bảng riêng và JOIN khi cần

2.3.6.3. Dạng Chuẩn 3 (Third Normal Form - 3NF)

**Định nghĩa 3NF:**
- Đã thỏa mãn 2NF
- Không có transitive dependency (thuộc tính không khóa không phụ thuộc vào 
  thuộc tính không khóa khác)

**Phân tích:**

**✅ Bảng CUSTOMERS:**
```
customers(id, fullName, username, passwordHash, phone, email, 
          currentBatteryUid, totalSwaps, balance, avatarUrl, createdAt)
```

**Kiểm tra transitive dependency:**

❌ **Potential violation:** `currentBatteryUid → Battery.status`
- Nếu lưu `currentBatteryStatus` trong `customers`:
```sql
customers(..., currentBatteryUid, currentBatteryStatus, ...)
```
- `currentBatteryStatus` phụ thuộc vào `currentBatteryUid` (transitive)
- `currentBatteryStatus` không phụ thuộc trực tiếp vào `id`

✅ **Giải pháp (đã áp dụng):**
- Chỉ lưu `currentBatteryUid` (foreign key)
- Lấy `status` qua JOIN: `SELECT ... FROM customers JOIN batteries ...`
- Tránh transitive dependency

**✅ Bảng STATIONS:**
```
stations(id, name, location, status, totalSlots, availableSlots, 
         lastMaintenance, createdAt)
```

**Kiểm tra:**
- `availableSlots` có phụ thuộc vào `totalSlots` không?
  + Không! `availableSlots` là dữ liệu động, tính từ số slots có pin
  + Không có quan hệ deterministic: `totalSlots=6` không xác định `availableSlots`
  + `availableSlots` được update real-time khi có giao dịch
- ✓ Không vi phạm 3NF

**✅ Bảng TRANSACTION_LOGS:**
```
transaction_logs(id, customerId, stationId, oldBatteryUid, newBatteryUid,
                 cost, transactionTime, completedTime, status)
```

**Kiểm tra:**
- `cost` có phụ thuộc vào `stationId` không?
  + Không! Hiện tại cost = 7000đ cố định
  + Trong tương lai, nếu mỗi trạm có giá khác nhau:
    ```sql
    -- Vi phạm 3NF nếu lưu:
    transaction_logs(..., stationId, stationPricePerSwap, cost, ...)
    -- cost phụ thuộc stationPricePerSwap, không phụ thuộc trực tiếp id
    ```
  + ✓ Giải pháp hiện tại: Cost lưu trực tiếp, hoặc JOIN với `stations.pricePerSwap`

**✅ Bảng SLOTS:**
```
slots(id, stationId, slotNumber, status, isBatteryPresent, isLocked, 
      batteryUid, lastUpdated)
```

**Kiểm tra:**
- `status` có phụ thuộc vào `isBatteryPresent` không?
  + Logic: `isBatteryPresent=true` → `status` có thể là "occupied" hoặc "charging"
  + KHÔNG phải functional dependency vì không xác định duy nhất
  + `status` và `isBatteryPresent` là 2 thuộc tính độc lập
- ✓ Không vi phạm 3NF

**✅ Bảng PAYMENTS:**
```
payments(id, customerId, orderId, requestId, amount, status, 
         paymentMethod, transactionId, momoData, createdAt, completedAt)
```

**Kiểm tra:**
- `momoData` chứa JSON từ MoMo, có thông tin trùng với các trường khác
- Có vi phạm 3NF không?
  + Không! `momoData` là audit log, không dùng cho business logic
  + Các trường `orderId`, `amount`, `status` là normalized data
  + `momoData` là raw response để debugging, không tạo dependency

**❌ Ví dụ vi phạm 3NF (không có trong hệ thống):**

Nếu thiết kế sai:
```sql
-- Lưu thông tin customer trong transaction
transaction_logs(id, customerId, customerName, customerPhone, ...)
```
- `customerName` phụ thuộc `customerId`
- `customerName` không phụ thuộc trực tiếp `id`
- → Transitive dependency: `id → customerId → customerName`

✅ **Giải pháp (đã áp dụng):**
```sql
-- Chỉ lưu foreign key
transaction_logs(id, customerId, ...)

-- Lấy thông tin qua JOIN
SELECT t.*, c.fullName, c.phone
FROM transaction_logs t
JOIN customers c ON t.customerId = c.id
```

**Kết luận 3NF:**
✅ Tất cả 12 bảng thỏa mãn 3NF vì:
- Không lưu thông tin derived có thể tính toán
- Không lưu thông tin của bảng liên quan (dùng JOIN)
- Foreign keys trỏ đến bảng gốc thay vì duplicate data
- Tránh transitive dependencies

2.3.6.4. Tổng kết Normalization

**Bảng kiểm tra chuẩn hóa:**

| Bảng | 1NF | 2NF | 3NF | Ghi chú |
|------|-----|-----|-----|---------|
| customers | ✅ | ✅ | ✅ | Chỉ lưu FK currentBatteryUid |
| batteries | ✅ | ✅ | ✅ | Không lưu customer info |
| stations | ✅ | ✅ | ✅ | location format chấp nhận |
| slots | ✅ | ✅ | ✅ | Không lưu station info |
| admins | ✅ | ✅ | ✅ | Tách biệt với customers |
| transaction_logs | ✅ | ✅ | ✅ | Chỉ lưu FK, JOIN để lấy detail |
| maintenance_logs | ✅ | ✅ | ✅ | FK to stations và admins |
| warehouse | ✅ | ✅ | ✅ | 1-1 với slot |
| warehouse_batteries | ✅ | ✅ | ✅ | Junction table |
| feedback | ✅ | ✅ | ✅ | Simple structure |
| reservations | ✅ | ✅ | ✅ | FK to customers và stations |
| payments | ✅ | ✅ | ✅ | momoData là audit log |

**Lợi ích của thiết kế chuẩn hóa:**

1. **Tránh dư thừa dữ liệu:**
   - Thông tin customer chỉ lưu trong bảng `customers`
   - Station info chỉ lưu trong bảng `stations`
   - Battery info chỉ lưu trong bảng `batteries`

2. **Tránh Update Anomaly:**
   ```sql
   -- Nếu customer đổi phone, chỉ update 1 chỗ
   UPDATE customers SET phone = '0987654321' WHERE id = 1;
   
   -- Không cần update trong transaction_logs, reservations, payments...
   -- Vì các bảng đó chỉ lưu customerId (FK)
   ```

3. **Tránh Insert Anomaly:**
   - Có thể thêm battery vào hệ thống mà không cần có customer
   - Có thể thêm station mà không cần có slots ngay lập tức

4. **Tránh Delete Anomaly:**
   - Xóa customer không làm mất thông tin battery
   - Xóa station với CASCADE sẽ xóa slots (intended behavior)
   - Xóa admin với SET NULL giữ lại maintenance logs (audit trail)

**Trade-offs chấp nhận:**

1. **stations.location format "address;lat;lng":**
   - Vi phạm nhẹ 1NF nhưng chấp nhận vì performance
   - Luôn dùng cùng nhau, không query riêng

2. **payments.momoData (JSONB):**
   - Chứa duplicate data nhưng chấp nhận vì:
     + Audit log, không dùng cho business logic
     + Semi-structured data từ external API
     + Cần giữ nguyên raw response để debug

3. **stations.availableSlots (derived data):**
   - Có thể tính từ COUNT(slots WHERE status='occupied')
   - Nhưng lưu riêng vì:
     + Performance: Tránh COUNT() trong mỗi query
     + Consistency: Update via transaction, đảm bảo accurate
     + Real-time requirement: Cần biết ngay availability

**Kết luận:**
Cơ sở dữ liệu EV-Swap tuân thủ 3NF với một số trade-offs hợp lý để cân bằng 
giữa normalization và performance trong thực tế.

2.3.7. DATA INTEGRITY VÀ CONSTRAINTS

2.3.6.1. Referential Integrity

Foreign keys đảm bảo:
- Không thể tạo Transaction với customerId không tồn tại
- Không thể assign batteryUid không hợp lệ cho Slot
- Không thể đặt Reservation cho Station đã bị xóa

2.3.6.2. Check Constraints (Application-level)

Backend kiểm tra:
- rating trong Feedback phải từ 1-5
- balance không được âm
- cost của transaction >= 0
- slotNumber trong khoảng 1 đến totalSlots

2.3.6.3. Default Values

Đảm bảo data consistency:
- status mặc định: "pending", "inactive", "in_stock"
- totalSwaps = 0 khi tạo mới customer
- balance = 0 khi đăng ký
- createdAt = NOW() tự động

2.3.7. MIGRATION STRATEGY

Sử dụng Prisma Migrate để quản lý schema changes:

```bash
# Tạo migration mới sau khi sửa schema.prisma
npx prisma migrate dev --name add_email_to_customers

# Deploy lên production
npx prisma migrate deploy
```

Migration history được lưu trong thư mục prisma/migrations/:
```
prisma/
└── migrations/
    ├── 20241201_init/
    ├── 20241205_add_reservations/
    └── 20241210_update_location_format/
```

================================================================================
KẾT LUẬN PHẦN 2.3

Thiết kế cơ sở dữ liệu của hệ thống EV-Swap đảm bảo:

**Cấu trúc tổng thể:**
1. Tính toàn vẹn dữ liệu qua foreign keys và constraints
2. Tính nhất quán qua ACID transactions
3. Khả năng mở rộng qua normalized structure
4. Performance tốt qua indexes và efficient queries
5. Dễ bảo trì qua Prisma Schema và migrations

**Các bảng chính (12 tables):**
1. **stations**: Trạm đổi pin
2. **batteries**: Quản lý các viên pin trong hệ thống
3. **customers**: Khách hàng sử dụng mobile app
4. **slots**: Khay chứa pin tại trạm
5. **admins**: Quản trị viên sử dụng admin web
6. **transaction_logs**: Lịch sử giao dịch đổi pin
7. **maintenance_logs**: Lịch sử bảo trì trạm do admin thực hiện
8. **warehouse**: Kho chứa pin dự phòng tại mỗi slot
9. **warehouse_batteries**: Pin trong kho warehouse
10. **feedback**: Phản hồi từ khách hàng
11. **reservations**: Đặt chỗ trước tại trạm
12. **payments**: Lịch sử nạp tiền qua MoMo

**Tách biệt rõ ràng:**
- **Customers vs Admins**: 2 bảng riêng cho 2 loại users
  + Customers: Sử dụng dịch vụ đổi pin, có balance và currentBatteryUid
  + Admins: Quản trị hệ thống, có role và thực hiện maintenance
- **TransactionLog vs Payment**: Giao dịch đổi pin vs nạp tiền
- **Slot vs Warehouse**: Pin đang sử dụng vs pin dự trữ

**Relationships phức tạp:**
- Battery có 2 relations với TransactionLog (oldBattery và newBattery)
- Station liên kết với Slots, Transactions, Reservations, MaintenanceLogs
- Admin quản lý MaintenanceLogs nhưng không liên quan đến Customers

**Cascade strategies:**
- ON DELETE CASCADE: Station → Slots (xóa trạm thì xóa slots)
- ON DELETE SET NULL: Battery → Customer (xóa pin thì customer.currentBatteryUid = NULL)
- ON DELETE SET NULL: Admin → MaintenanceLog (xóa admin nhưng giữ log)

**Indexes tự động:**
- Primary keys: Tất cả bảng
- Foreign keys: Tự động index bởi Prisma
- Unique constraints: username, email, phone, orderId

Database schema này là nền tảng vững chắc cho toàn bộ hệ thống, hỗ trợ các 
tính năng từ đăng nhập (customers và admins), đổi pin, thanh toán đến quản lý 
trạm, bảo trì và thống kê.
================================================================================
